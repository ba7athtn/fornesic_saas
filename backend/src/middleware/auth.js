const jwt = require('jsonwebtoken');
const crypto = require('crypto');
const rateLimit = require('express-rate-limit'); // ‚úÖ CORRECTION - Supprimer import ip inexistant

// =====================================
// VALIDATION ENVIRONNEMENT CRITIQUE
// =====================================

const requiredEnvVars = ['JWT_SECRET', 'JWT_REFRESH_SECRET'];
const missingVars = requiredEnvVars.filter(varName => !process.env[varName]);

if (missingVars.length > 0) {
  console.error('‚ùå Variables JWT manquantes:', missingVars.join(', '));
  process.exit(1);
}

// Validation s√©curit√© des secrets
if (process.env.JWT_SECRET.length < 32) {
  console.error('‚ùå JWT_SECRET doit faire au moins 32 caract√®res');
  process.exit(1);
}

// =====================================
// RATE LIMITING SP√âCIALIS√â FORENSIQUE - ‚úÖ CORRIG√â IPv6
// =====================================

const authRateLimit = rateLimit({
  windowMs: (parseInt(process.env.RATE_LIMIT_FORENSIC_WINDOW_MINUTES) || 5) * 60 * 1000,
  max: parseInt(process.env.RATE_LIMIT_FORENSIC_MAX_REQUESTS) || 10,
  message: {
    error: 'Trop de tentatives d\'authentification',
    retryAfter: Math.ceil((parseInt(process.env.RATE_LIMIT_FORENSIC_WINDOW_MINUTES) || 5) * 60),
    forensicNote: 'Acc√®s aux fonctions forensiques limit√© pour s√©curit√©'
  },
  standardHeaders: true,
  legacyHeaders: false,
  // ‚úÖ CORRECTION IPv6 - Utiliser req.ip directement au lieu de ip() inexistant
  keyGenerator: (req) => {
    const clientIp = req.ip || req.connection.remoteAddress || req.socket.remoteAddress || 'unknown';
    const identifier = crypto.createHash('sha256')
      .update(clientIp + (req.get('User-Agent') || ''))
      .digest('hex')
      .substring(0, 16);
    return identifier;
  },
  validate: {
    keyGeneratorIpFallback: false // D√©sactive le warning IPv6
  },
  handler: (req, res) => {
    console.warn('üö® Rate limit auth d√©pass√©:', {
      ip: req.ip,
      userAgent: req.get('User-Agent'),
      endpoint: req.path,
      timestamp: new Date().toISOString(),
      method: req.method
    });

    res.status(429).json({
      error: 'Trop de tentatives d\'authentification',
      type: 'RATE_LIMIT_EXCEEDED',
      retryAfter: Math.ceil((parseInt(process.env.RATE_LIMIT_FORENSIC_WINDOW_MINUTES) || 5) * 60),
      timestamp: new Date().toISOString()
    });
  }
});

// =====================================
// FONCTION D'AUTHENTIFICATION PRINCIPALE
// =====================================

function auth(req, res, next) {
  const startTime = Date.now();
  
  try {
    // Extraction et validation du header Authorization
    const authHeader = req.headers.authorization;
    if (!authHeader) {
      return sendAuthError(res, 'TOKEN_MISSING', 'Header Authorization manquant', {
        expected: 'Bearer <token>',
        received: 'none'
      });
    }

    if (!authHeader.startsWith('Bearer ')) {
      return sendAuthError(res, 'INVALID_TOKEN_FORMAT', 'Format de token invalide', {
        expected: 'Bearer <token>',
        received: authHeader.substring(0, 20) + '...'
      });
    }

    const token = authHeader.split(' ')[1];
    if (!token || token.trim().length === 0) {
      return sendAuthError(res, 'EMPTY_TOKEN', 'Token vide fourni');
    }

    // Validation format JWT basique
    const jwtParts = token.split('.');
    if (jwtParts.length !== 3) {
      return sendAuthError(res, 'MALFORMED_TOKEN', 'Structure JWT invalide');
    }

    // V√©rification JWT avec options s√©curis√©es
    const decoded = jwt.verify(token, process.env.JWT_SECRET, {
      algorithms: ['HS256'], // Forcer l'algorithme pour la s√©curit√©
      maxAge: process.env.JWT_EXPIRE || '24h',
      clockTolerance: 30, // 30 secondes de tol√©rance horloge
      ignoreExpiration: false,
      ignoreNotBefore: false
    });

    // Validation du contenu d√©cod√©
    if (!decoded || typeof decoded !== 'object') {
      return sendAuthError(res, 'INVALID_TOKEN_CONTENT', 'Contenu de token invalide');
    }

    // Validation champs obligatoires
    const requiredFields = ['sub', 'iat', 'exp'];
    const missingFields = requiredFields.filter(field => !decoded[field]);
    if (missingFields.length > 0) {
      return sendAuthError(res, 'INCOMPLETE_TOKEN', 'Champs token manquants', {
        missing: missingFields
      });
    }

    // Validation expiration personnalis√©e (double check)
    const now = Math.floor(Date.now() / 1000);
    if (decoded.exp <= now) {
      return sendAuthError(res, 'TOKEN_EXPIRED', 'Token expir√©', {
        expiredAt: new Date(decoded.exp * 1000).toISOString(),
        currentTime: new Date().toISOString()
      });
    }

    // Validation jti (JWT ID) si pr√©sent pour √©viter replay attacks
    if (decoded.jti && !isValidJti(decoded.jti)) {
      return sendAuthError(res, 'INVALID_JTI', 'JWT ID invalide ou r√©voqu√©');
    }

    // Enrichir req.user avec donn√©es d√©cod√©es et m√©tadonn√©es forensiques
    req.user = {
      ...decoded,
      // M√©tadonn√©es forensiques
      authMethod: 'jwt',
      authTimestamp: new Date().toISOString(),
      tokenIssuedAt: new Date(decoded.iat * 1000).toISOString(),
      tokenExpiresAt: new Date(decoded.exp * 1000).toISOString(),
      requestId: generateRequestId(),
      ipAddress: req.ip,
      userAgent: req.get('User-Agent')
    };

    // Headers de s√©curit√© forensique
    res.setHeader('X-Auth-Status', 'authenticated');
    res.setHeader('X-Auth-Method', 'jwt');
    res.setHeader('X-Request-Id', req.user.requestId);
    res.setHeader('X-Auth-Timestamp', req.user.authTimestamp);

    // Logging r√©ussite authentification (sans donn√©es sensibles)
    console.log('‚úÖ Authentification r√©ussie:', {
      userId: decoded.sub,
      requestId: req.user.requestId,
      ip: req.ip,
      path: req.path,
      method: req.method,
      authDuration: Date.now() - startTime + 'ms',
      timestamp: new Date().toISOString()
    });

    // Chain of custody pour acc√®s forensique
    if (req.path.includes('/api/analysis') || req.path.includes('/api/reports')) {
      req.chainOfCustodyEntry = {
        action: 'API_ACCESS',
        performedBy: decoded.sub || 'unknown',
        timestamp: new Date(),
        details: {
          endpoint: `${req.method} ${req.path}`,
          requestId: req.user.requestId,
          authMethod: 'jwt'
        }
      };
    }

    next();

  } catch (err) {
    const processingTime = Date.now() - startTime;
    
    // Gestion d'erreurs JWT sp√©cifiques avec logging forensique
    let errorCode, errorMessage, statusCode = 401;

    switch (err.name) {
      case 'TokenExpiredError':
        errorCode = 'TOKEN_EXPIRED';
        errorMessage = 'Token JWT expir√©';
        break;
      case 'JsonWebTokenError':
        errorCode = 'MALFORMED_TOKEN';
        errorMessage = 'Token JWT malform√© ou invalide';
        break;
      case 'NotBeforeError':
        errorCode = 'TOKEN_NOT_ACTIVE';
        errorMessage = 'Token pas encore actif (nbf)';
        break;
      default:
        errorCode = 'AUTH_ERROR';
        errorMessage = 'Erreur d\'authentification';
        statusCode = 500;
    }

    // Logging s√©curis√© des tentatives √©chou√©es
    console.warn('‚ö†Ô∏è Tentative d\'authentification √©chou√©e:', {
      errorCode: errorCode,
      errorName: err.name,
      ip: req.ip,
      path: req.path,
      method: req.method,
      userAgent: req.get('User-Agent')?.substring(0, 100),
      processingTime: processingTime + 'ms',
      timestamp: new Date().toISOString(),
      // Ne pas logger le token pour s√©curit√©
      tokenLength: req.headers.authorization?.length || 0
    });

    return res.status(statusCode).json({
      error: errorMessage,
      type: errorCode,
      timestamp: new Date().toISOString(),
      requestId: generateRequestId(),
      ...(process.env.NODE_ENV === 'development' && {
        debug: {
          errorName: err.name,
          processingTime: processingTime + 'ms'
        }
      })
    });
  }
}

// =====================================
// MIDDLEWARE AUTHENTIFICATION OPTIONNELLE
// =====================================

function optionalAuth(req, res, next) {
  const authHeader = req.headers.authorization;
  
  if (!authHeader || !authHeader.startsWith('Bearer ')) {
    // Pas d'authentification, continuer sans user
    req.user = null;
    res.setHeader('X-Auth-Status', 'anonymous');
    return next();
  }

  // Utiliser l'auth normale si token pr√©sent
  auth(req, res, next);
}

// =====================================
// MIDDLEWARE V√âRIFICATION R√îLES FORENSIQUES
// =====================================

function requireRole(roles) {
  return (req, res, next) => {
    if (!req.user) {
      return sendAuthError(res, 'AUTHENTICATION_REQUIRED', 'Authentification requise pour cette action');
    }

    const userRoles = req.user.roles || [];
    const hasRequiredRole = Array.isArray(roles)
      ? roles.some(role => userRoles.includes(role))
      : userRoles.includes(roles);

    if (!hasRequiredRole) {
      console.warn('üö´ Acc√®s refus√© - r√¥le insuffisant:', {
        userId: req.user.sub,
        userRoles: userRoles,
        requiredRoles: roles,
        endpoint: `${req.method} ${req.path}`,
        ip: req.ip,
        timestamp: new Date().toISOString()
      });

      return res.status(403).json({
        error: 'Permissions insuffisantes',
        type: 'INSUFFICIENT_PERMISSIONS',
        required: roles,
        current: userRoles,
        timestamp: new Date().toISOString()
      });
    }

    next();
  };
}

// =====================================
// MIDDLEWARE VALIDATION PRIVACY MODE
// =====================================

function requirePrivacyMode(allowedModes) {
  return (req, res, next) => {
    const currentMode = process.env.PRIVACY_MODE || 'COMMERCIAL';
    const allowed = Array.isArray(allowedModes) ? allowedModes : [allowedModes];

    if (!allowed.includes(currentMode)) {
      console.warn('üîí Acc√®s refus√© - mode privacy insuffisant:', {
        currentMode: currentMode,
        requiredModes: allowed,
        endpoint: `${req.method} ${req.path}`,
        userId: req.user?.sub,
        ip: req.ip,
        timestamp: new Date().toISOString()
      });

      return res.status(403).json({
        error: 'Mode de confidentialit√© insuffisant',
        type: 'PRIVACY_MODE_INSUFFICIENT',
        currentMode: currentMode,
        requiredModes: allowed,
        timestamp: new Date().toISOString()
      });
    }

    // Ajouter mode privacy au context
    req.privacyMode = currentMode;
    res.setHeader('X-Privacy-Mode', currentMode);
    next();
  };
}

// =====================================
// FONCTIONS UTILITAIRES
// =====================================

function sendAuthError(res, type, message, details = {}) {
  const errorResponse = {
    error: message,
    type: type,
    timestamp: new Date().toISOString(),
    requestId: generateRequestId()
  };

  if (Object.keys(details).length > 0) {
    errorResponse.details = details;
  }

  return res.status(401).json(errorResponse);
}

function generateRequestId() {
  return crypto.randomBytes(8).toString('hex');
}

function isValidJti(jti) {
  // V√©rifier si le JTI est dans une blacklist (Redis recommand√© en production)
  // Pour l'instant, validation basique du format
  return /^[a-f0-9-]{8,}$/.test(jti);
}

// =====================================
// MIDDLEWARE LOGGING FORENSIQUE
// =====================================

function forensicLogging(req, res, next) {
  const startTime = Date.now();

  // Intercepter la r√©ponse pour logging complet
  const originalSend = res.send;
  res.send = function(body) {
    const processingTime = Date.now() - startTime;

    // Log forensique s√©curis√©
    console.log('üîç Acc√®s API forensique:', {
      requestId: req.user?.requestId || generateRequestId(),
      userId: req.user?.sub || 'anonymous',
      method: req.method,
      path: req.path,
      statusCode: res.statusCode,
      processingTime: processingTime + 'ms',
      timestamp: new Date().toISOString(),
      ip: req.ip,
      userAgent: req.get('User-Agent')?.substring(0, 100),
      // Pas de body pour √©viter fuite de donn√©es
      responseSize: body ? Buffer.byteLength(body, 'utf8') : 0
    });

    originalSend.call(this, body);
  };

  next();
}

// =====================================
// EXPORTS
// =====================================

module.exports = {
  auth,
  optionalAuth,
  requireRole,
  requirePrivacyMode,
  forensicLogging,
  authRateLimit
};
